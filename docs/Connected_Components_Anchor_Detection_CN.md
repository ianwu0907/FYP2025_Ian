# 连通组件锚点检测算法

## 概述

连通组件锚点检测算法是一种**O(RC)复杂度**的方法，用于识别电子表格中的结构锚点。它用基于图的算法取代了之前**O(R⁴C⁴)**复杂度的启发式方法，通过分析单元格相似性模式来高效检测重要的行和列。

**代码位置**: `spreadsheet-normalizer/src/encoder/spreadsheet_encoder.py:477-738`

---

## 算法设计

### 问题陈述

给定一个包含R行C列的电子表格，识别一组"锚点"行和列，这些锚点代表结构上重要的区域（标题、数据边界、格式化区域），用于下游的LLM处理。

### 核心创新

我们不再使用需要昂贵计算的变异系数(CV)启发式方法，而是：
1. 构建一个**连通图**，其中相似的相邻单元格相连
2. 找到**连通组件**（相似单元格的群组）
3. 提取每个组件的**边界框边界**作为锚点
4. 使用**k邻域**扩展锚点以捕获周围上下文

---

## 算法组件

### 1. 单元格相似度检测

#### `get_fill_color(cell)` → str
提取单元格的填充颜色用于样式比较。

**返回值**:
- RGB颜色字符串（例如 `"FF0000"` 表示红色）
- `"index_X"` 表示索引颜色
- `"none"` 表示无填充颜色

**实现**:
```python
if fill.patternType == 'solid':
    if fill.fgColor.rgb:
        return str(fill.fgColor.rgb)
```

---

#### `has_border(cell)` → bool
检查单元格是否有边框样式。

**返回值**: 如果单元格有左/右/上/下边框则返回`True`

---

#### `cells_similar(cell1, cell2, threshold=0.75)` → bool
使用**加权评分**确定两个单元格是否应属于同一连通区域。

**评分系统**（总权重：10.0）:

| 特征 | 权重 | 描述 |
|---------|--------|-------------|
| 字体加粗 | 2.0 | 两个单元格是否具有相同的加粗状态 |
| 填充颜色 | 3.0 | 两个单元格是否具有相同的背景颜色 |
| 边框 | 1.5 | 两个单元格是否具有相同的边框存在性 |
| 数据类型 | 2.0 | 两个单元格是否具有相同的值类型（int、str等） |
| 数字格式 | 1.5 | 两个单元格是否使用相同的数字格式字符串 |

**算法**:
```
score = 0.0
total = 10.0

if cell1.font.bold == cell2.font.bold:
    score += 2.0
if get_fill_color(cell1) == get_fill_color(cell2):
    score += 3.0
if has_border(cell1) == has_border(cell2):
    score += 1.5
if type(cell1.value) == type(cell2.value):
    score += 2.0
if cell1.number_format == cell2.number_format:
    score += 1.5

return (score / total) >= threshold  # 默认值：75%
```

**阈值**: 默认0.75意味着单元格必须在≥75%的加权特征上匹配。

---

### 2. 连通图构建

#### `build_connectivity_graph(sheet, region)` → Dict[str, Set[str]]

构建一个无向图，其中节点是单元格，边连接相似的相邻单元格。

**复杂度**: **O(RC)** - 每个单元格只访问一次，仅检查右侧和下方邻居。

**算法**:
```
对于区域中的每个单元格 (r, c):
    如果为空则跳过

    检查右侧邻居 (r, c+1):
        如果非空 且 cells_similar():
            添加边: cell ↔ right_neighbor

    检查下方邻居 (r+1, c):
        如果非空 且 cells_similar():
            添加边: cell ↔ bottom_neighbor
```

**为什么只检查右侧和下方？**
- 避免重复计算边（无向图）
- 左侧邻居在处理前一个单元格时已检查
- 上方邻居在处理前一行时已检查

**示例输出**:
```python
{
    "A1": {"A2", "B1"},  # A1连接到A2（下方）和B1（右侧）
    "A2": {"A1", "A3"},  # A2连接到A1（上方）和A3（下方）
    "B1": {"A1", "B2"},  # B1连接到A1（左侧）和B2（下方）
    ...
}
```

---

### 3. 连通组件检测

#### `find_connected_components(graph, min_component_size=4)` → List[List[str]]

使用**深度优先搜索(DFS)**查找所有连通组件。

**复杂度**: **O(V + E) = O(RC)**，其中：
- V = 非空单元格数量 ≤ RC
- E = 边的数量 ≤ 2RC（每个单元格最多添加2条边）

**算法**:
```
visited = set()
components = []

对于每个起始单元格:
    如果已访问，跳过

    component = []
    stack = [starting_cell]

    当栈不为空:
        cell = stack.pop()
        如果已访问，继续

        标记cell为已访问
        将cell添加到component

        对于cell的每个邻居:
            如果未访问:
                将邻居添加到栈

    如果组件大小 ≥ min_component_size:
        保存组件

按大小排序组件（最大的在前）
```

**过滤**: 少于4个单元格的组件被视为噪声而丢弃。

**示例输出**:
```python
[
    ["A1", "A2", "A3", "B1", "B2", "B3"],  # 标题区域（6个单元格）
    ["A5", "B5", "C5", "D5"],              # 数据行（4个单元格）
    ["E1", "E2", "E3", "F1", "F2"],        # 侧边栏（5个单元格）
]
```

---

### 4. 边界提取

#### `extract_component_boundaries(components)` → Tuple[Set[int], Set[int]]

提取每个组件的边界框边界作为锚点候选。

**复杂度**: **O(total_cells)** - 对所有组件中的所有单元格进行线性扫描。

**算法**:
```
row_boundaries = set()
col_boundaries = set()

对于每个组件:
    min_row = 组件中所有行的最小值
    max_row = 组件中所有行的最大值
    min_col = 组件中所有列的最小值
    max_col = 组件中所有列的最大值

    添加到边界:
        row_boundaries += {min_row, max_row}
        col_boundaries += {min_col, max_col}

返回 (row_boundaries, col_boundaries)
```

**示例**:
```
组件: ["A1", "A2", "B1", "B2"]
边界框: 行 [1, 2], 列 [A=1, B=2]
提取结果: row_boundaries={1, 2}, col_boundaries={1, 2}
```

---

### 5. K邻域扩展

#### `expand_with_k_neighborhood(indices, k, max_index)` → List[int]

通过在每侧包含k个单元格来扩展锚点索引。

**复杂度**: **O(|indices| × k)** - 对于每个锚点，在每侧添加k个邻居。

**算法**:
```
expanded = set()

对于indices中的每个anchor_idx:
    对于范围(-k, k+1)中的每个offset:
        expanded_idx = anchor_idx + offset
        如果 1 ≤ expanded_idx ≤ max_index:
            expanded.add(expanded_idx)

返回 sorted(expanded)
```

**示例** (k=2):
```
输入: anchors = {5, 10}
输出: {3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
        └─────┬─────┘  └────────┬────────┘
         5 ± 2           10 ± 2
```

**目的**: 捕获重要边界周围的上下文（标题通常跨越多行）。

---

### 6. 主算法

#### `fast_find_structural_anchors(sheet, k, region)` → Tuple[List[int], List[int]]

协调所有步骤的主入口点。

**复杂度**: 总体**O(RC)**

**流程**:
```
步骤1: 构建连通图                O(RC)
    ↓
步骤2: 查找连通组件              O(RC)
    ↓
步骤3: 提取边界                  O(RC)
    ↓
步骤4: K邻域扩展                 O(anchors × k)
    ↓
返回: (row_anchors, col_anchors)
```

**回退策略**:
- 如果图少于4个单元格: 使用区域边界
- 如果未找到组件: 使用区域边界
- 确保算法始终返回有效锚点

**完整运行示例**:
```python
# 输入: 100行×50列的表格, k=2

# 步骤1: 构建图
graph = {
    "A1": {"B1", "A2"},
    "B1": {"A1", "C1"},
    ...  # 2000个非空单元格 → ~4000条边
}

# 步骤2: 查找组件（找到5个组件）
components = [
    ["A1", "B1", "C1", ...],  # 20单元格标题
    ["A5", "B5", "C5", ...],  # 15单元格子标题
    ...
]

# 步骤3: 提取边界
row_boundaries = {1, 5, 6, 10, 15, ...}  # 10个边界
col_boundaries = {1, 3, 5, 10, ...}      # 8个边界

# 步骤4: 使用k=2扩展
row_anchors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]  # 28行
col_anchors = [1, 2, 3, 4, 5, 6, 7, ...]            # 22列

# 最终: 只保留28×22 = 616个单元格，而不是5000个！
```

---

## 复杂度分析

### 时间复杂度: O(RC)

| 步骤 | 复杂度 | 原因 |
|------|-----------|---------|
| 构建图 | O(RC) | 访问每个单元格一次，检查2个邻居 |
| 查找组件 | O(V + E) = O(RC) | 在具有V≤RC个顶点、E≤2RC条边的图上进行DFS |
| 提取边界 | O(total_cells) ≤ O(RC) | 对组件进行线性扫描 |
| 扩展邻域 | O(anchors × k) | anchors << RC, k是常数 |
| **总计** | **O(RC)** | 与电子表格大小呈线性关系 |

### 空间复杂度: O(RC)

- 图存储: O(非空单元格 + 边) ≤ O(RC)
- 已访问集合: O(非空单元格) ≤ O(RC)
- 组件列表: O(非空单元格) ≤ O(RC)

---

## 与之前方法的比较

### 旧方法: 基于CV的启发式
- **复杂度**: O(R⁴C⁴)
- **方法**: 计算所有可能矩形区域的变异系数
- **问题**: 实际上呈指数级，大型电子表格速度慢

### 新方法: 连通组件
- **复杂度**: O(RC)
- **方法**: 基于图的结构分析
- **优势**: 线性复杂度，可扩展到大型电子表格

**加速示例**:
- 100×50电子表格: 旧方法 = 625,000,000,000次操作 → 新方法 = 5,000次操作
- **改进: 快125,000,000倍！**

---

## 实际示例

### 输入电子表格
```
     A         B         C         D         E
1  [姓名]    [年龄]    [城市]   [分数]    [等级]  ← 加粗，彩色标题
2  Alice     25       NYC      95        A
3  Bob       30       LA       87        B
4  Carol     28       SF       92        A
5
6  [总计]    [平均]    [最大]              ← 加粗，彩色汇总
7  3         27.7     95
```

### 逐步执行

**1. 构建图** (k=1)
```
检测到的相似性:
- A1 ↔ B1 ↔ C1 ↔ D1 ↔ E1  (相同加粗，相同颜色)
- A6 ↔ B6 ↔ C6             (相同加粗，相同颜色)
- A2 ↔ A3 ↔ A4             (相同格式，相同列)
- B2 ↔ B3 ↔ B4             (相同格式，数字)
...
```

**2. 查找组件**
```
组件1: 标题行
  ["A1", "B1", "C1", "D1", "E1"]
  边界框: 行 [1, 1], 列 [1, 5]

组件2: 汇总行
  ["A6", "B6", "C6"]
  边界框: 行 [6, 6], 列 [1, 3]

组件3: 数据列A
  ["A2", "A3", "A4"]
  边界框: 行 [2, 4], 列 [1, 1]
```

**3. 提取边界**
```
row_boundaries = {1, 2, 4, 6}
col_boundaries = {1, 3, 5}
```

**4. 使用k=1扩展**
```
row_anchors = {1, 2, 3, 4, 5, 6, 7}  (边界±1范围内的所有行)
col_anchors = {1, 2, 3, 4, 5}        (边界±1范围内的所有列)
```

**5. 最终结果**
- 保留所有7行×5列 = 35个单元格
- 原始: 7×5 = 35个单元格
- 压缩: 1.0倍（小表格无压缩）
- **但算法识别出了重要结构！**

---

## 优势

### 1. **高效复杂度**
- O(RC)与电子表格大小呈线性扩展
- 适用于大型电子表格（数千行/列）

### 2. **结构感知**
- 自动识别标题、页脚和数据区域
- 基于实际单元格样式，而非任意启发式

### 3. **鲁棒性**
- 适用于各种电子表格布局
- 处理合并单元格、彩色区域、加粗标题等

### 4. **可配置**
- `k`参数控制锚点邻域大小
- `cells_similar()`中的`threshold`控制相似性严格程度
- `min_component_size`过滤噪声

### 5. **回退策略**
- 始终返回有效锚点（如果没有其他内容则使用区域边界）
- 永不完全失败

---

## 局限性与未来工作

### 当前局限性

1. **二元相似性**: `cells_similar()`使用固定权重
   - 未来: 从示例中学习权重

2. **固定阈值**: 75%相似度可能不适合所有电子表格
   - 未来: 基于表格特征的自适应阈值

3. **无语义理解**: 仅考虑样式
   - 未来: 结合内容分析（例如"总计"关键词）

### 潜在改进

1. **多遍分析**: 使用不同阈值运行并合并结果
2. **层次组件**: 检测嵌套结构（标题内的子标题）
3. **机器学习**: 训练分类器预测锚点重要性
4. **基于内容的特征**: 添加语义相似性（不仅仅是样式）

---

## 与SpreadsheetLLM流程的集成

锚点检测用于完整的编码流程中：

```
输入: Excel文件
    ↓
1. 使用openpyxl加载（保留格式）
    ↓
2. 检测表格区域（按空白行/标题分割）
    ↓
3. 对于每个区域:
    ↓
    a. 查找结构锚点（本算法）
    ↓
    b. 提取锚点附近的单元格（k邻域）
    ↓
    c. 创建倒排索引（值 → 单元格）
    ↓
    d. 聚合格式区域
    ↓
    e. 构建压缩的JSON编码
    ↓
输出: SpreadsheetLLM风格的编码
```

**锚点检测**（步骤3a）是决定哪些单元格对下游LLM处理重要的基础。

---

## 参考资料

### 代码位置
- `spreadsheet_encoder.py:477-738` - 完整实现
- `spreadsheet_encoder.py:694-738` - 主入口点 `fast_find_structural_anchors()`

### 相关算法
- **图连通性**: 经典的基于DFS的连通组件算法
- **电子表格分析**: 受文档布局分析技术启发
- **SpreadsheetLLM**: Chen等人，"SpreadsheetLLM: Encoding Spreadsheets for Large Language Models"

---

## 使用示例

```python
from spreadsheet_encoder import fast_find_structural_anchors
import openpyxl

# 加载电子表格
wb = openpyxl.load_workbook("data.xlsx")
sheet = wb.active

# 查找锚点（k=2邻域）
row_anchors, col_anchors = fast_find_structural_anchors(
    sheet,
    k=2,
    region=None  # 使用整个表格
)

print(f"找到{len(row_anchors)}个行锚点: {row_anchors[:10]}...")
print(f"找到{len(col_anchors)}个列锚点: {col_anchors[:10]}...")

# 输出:
# 找到28个行锚点: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
# 找到22个列锚点: [1, 2, 3, 4, 5, 6, 7, 8, 9, ...]
```

---

## 总结

连通组件锚点检测算法提供了一种**高效的O(RC)**方法来识别电子表格中结构上重要的区域。通过基于单元格相似性构建连通图并提取连通组件的边界框边界，它用有原则的基于图的方法取代了昂贵的启发式方法。

**核心要点**: 将电子表格分析从CV启发式问题转变为图连通性问题，在保持准确性的同时实现了大幅加速。
